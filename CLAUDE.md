# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

**Arke IPFS API Service** - A Cloudflare Worker that provides a versioned entity management API over IPFS/Kubo. This service manages immutable manifests (stored as IPLD dag-json) with version chains, using MFS `.tip` files for fast lookups.

## Development Commands

### Local Development
```bash
npm run dev          # Start local dev server (port 8787)
npm run type-check   # Run TypeScript type checking
npm run test         # Run tests with Vitest
```

### Deployment
```bash
npm run deploy       # Deploy to Cloudflare Workers
```

### Configuration
```bash
wrangler secret put IPFS_API_URL   # Set IPFS node URL (e.g., http://ipfs-kubo:5001)
```

## Architecture

### Two-Layer Storage Model

The system uses a dual-layer approach combining IPFS immutable content with MFS mutable pointers:

1. **MFS Layer** (`/arke/index/` directory)
   - Stores `.tip` files that point to the latest manifest CID for each entity
   - Sharded directory structure: `/arke/index/{PI[-4:-2]}/{PI[-2:]}/{PI}.tip`
   - Uses last 4 chars of ULID (random portion) for uniform distribution
   - Example: PI `01K75HQQXNTDG7BBP7PS9AWYAN` → `/arke/index/AW/YA/01K75HQQXNTDG7BBP7PS9AWYAN.tip`
   - Enables fast PI → latest CID lookups without traversing version history

2. **IPFS Layer** (immutable content)
   - Stores versioned manifests as dag-json with IPLD links
   - Version chain via `prev` links: v3 → v2 → v1 (genesis)
   - Components (files/metadata) stored as raw or dag-pb
   - All content is pinned for permanence

3. **Backend Event Stream** (delegated to IPFS Server API)
   - Event-sourced tracking of all creates and updates
   - Each event records: `type` (create/update), `pi`, `ver`, `tip_cid`, `ts`
   - Enables efficient entity listing, mirroring, and change tracking
   - Snapshots provide point-in-time checkpoints for incremental sync
   - Backend URL configured via `IPFS_SERVER_API_URL` environment variable

### Key Services

**IPFSService** (`src/services/ipfs.ts`)
- Wrapper around Kubo HTTP RPC API
- All methods use POST to `/api/v0/*` endpoints
- Handles: file upload, dag operations, MFS operations, pinning
- Error handling with `IPFSError` wrapping

**TipService** (`src/services/tip.ts`)
- Manages `.tip` files in MFS
- Provides PI sharding logic (2-level directory structure)
- Implements entity listing via recursive MFS scanning
- CAS (Compare-And-Swap) operations via tip reading/writing

### Routing Structure

The API uses Hono framework with route handlers in `src/handlers/`:
- `upload.ts` - File uploads to IPFS
- `download.ts` - File downloads by CID
- `entities.ts` - Create entity, get entity, list entities
- `versions.ts` - Append version, list versions, get specific version
- `relations.ts` - Update parent-child relationships
- `resolve.ts` - Fast PI → tip CID resolution

Middleware initializes services and injects them into context (`c.set('ipfs', ...)`)

### Data Model

**Manifest Structure** (stored as dag-json):
```typescript
{
  schema: "arke/manifest@v1",
  pi: string,              // ULID (26-char base32)
  ver: number,             // Version number (1, 2, 3...)
  ts: string,              // ISO 8601 timestamp
  prev: IPLDLink | null,   // Link to previous version
  components: {            // Named CID references
    [label]: IPLDLink
  },
  children_pi?: string[],  // Optional child entity PIs
  note?: string            // Optional change description
}
```

**IPLD Link Format**: `{ "/": "bafyrei..." }`

**Persistent Identifier (PI)**:
- Format: ULID (26 characters, base32 Crockford alphabet)
- Example: `01K75HQQXNTDG7BBP7PS9AWYAN`
- Can be auto-generated by server or provided by client
- Must be unique (409 error if collision)

### Validation

Uses Zod schemas (defined in `src/types/manifest.ts`) for:
- Request validation (CreateEntityRequest, AppendVersionRequest, etc.)
- Manifest validation (ManifestV1Schema)
- Runtime type safety

ULID validation regex: `/^[0-9A-HJKMNP-TV-Z]{26}$/`

### Error Handling

Custom error types in `src/utils/errors.ts`:
- `ValidationError` (400)
- `NotFoundError` (404)
- `ConflictError` (409) - for PI conflicts and CAS failures
- `IPFSError` (503)

All errors converted to JSON responses via `errorToResponse()`

## Important Implementation Details

### Testnet (Network Isolation)

The API supports separate test and main networks to prevent mixing test and production data.

**Network Header:**
- Header: `X-Arke-Network: main` (default) or `X-Arke-Network: test`
- Missing header defaults to `main` (backward compatible)
- Invalid header value returns 400 error

**PI Prefix Convention:**
- **Main network**: Standard ULIDs (e.g., `01K75HQQXNTDG7BBP7PS9AWYAN`)
- **Test network**: PIs prefixed with `II` (e.g., `IIAK75HQQXNTDG7BBP7PS9AWY`)
- `II` prefix uses the letter 'I' which is excluded from Crockford Base32, making it impossible for a real ULID to ever start with `II`
- Server-generated test PIs automatically get the `II` prefix
- Client-provided test PIs must start with `II`

**MFS Storage Paths:**
- **Main**: `/arke/index/{shard1}/{shard2}/{pi}.tip`
- **Test**: `/arke/test/index/{shard1}/{shard2}/{pi}.tip`

**Cross-Network Prevention:**
All endpoints validate that PIs match the requested network:
- Cannot create test entity with main network parent
- Cannot add main network children to test entity
- Cannot access test entity without `X-Arke-Network: test` header
- Error: 400 `VALIDATION_ERROR` with message explaining network mismatch

**Implementation Files:**
- `src/types/network.ts` - Network type, validation helpers, PI prefix constants
- `src/utils/ulid.ts` - `generatePi(network)` function
- `src/services/tip.ts` - Network-aware MFS paths

**Usage Example:**
```bash
# Create entity on test network
curl -X POST http://localhost:8787/entities \
  -H "X-Arke-Network: test" \
  -H "Content-Type: application/json" \
  -d '{"components": {"data": "bafyrei..."}}'
# Returns: {"pi": "IIAK75HQQ...", "ver": 1, ...}

# Access test entity (requires header)
curl http://localhost:8787/entities/IIAK75HQQ... \
  -H "X-Arke-Network: test"
```

### Atomic CAS Protection (Race Condition Prevention)

All write operations use atomic Compare-And-Swap (CAS) to prevent data loss from concurrent updates.

**Endpoints with Atomic CAS:**
- `POST /entities/:pi/versions` - Version appending
- `POST /relations` - Parent-child relationship updates
- `POST /entities` with `parent_pi` - Parent auto-update during entity creation

**How it works:**
1. Client provides `expect_tip` (current manifest CID)
2. Server reads actual tip from MFS and validates CAS
3. If mismatch → 409 CAS_FAILURE error with `{ expected, actual }` details
4. If match → create new manifest with incremented version
5. Update tip atomically with race detection and automatic retry

**Atomic CAS Implementation** (`src/services/tip.ts:76-114`):
- **Pre-write verification**: Re-checks tip hasn't changed before writing
- **Post-write verification**: Verifies our write succeeded after writing
- **Race detection**: Throws `TipWriteRaceError` if another writer won the race
- **Automatic retry**: Handlers retry up to 3 times with exponential backoff (50ms → 100ms → 200ms)
- **Idempotent**: Each retry fetches fresh manifest data, ensuring correct component/relationship merging

**Concurrent Update Behavior:**
If two updates happen simultaneously:
- First write succeeds and creates version N
- Second write detects race internally, retries automatically, and creates version N+1 with both updates merged
- Client only sees successful 201 response - race handling is transparent

**Client vs Server Responsibilities:**
- ❌ **Don't**: Implement client-side retry loops for internal races
- ✅ **Do**: Provide correct `expect_tip` based on latest read
- ✅ **Do**: Handle 409 CAS_FAILURE by fetching new tip and resubmitting (this means client's `expect_tip` was stale)
- ✅ **Server handles**: Internal race detection and retry (TipWriteRaceError)

### Version History Traversal

- **Forward traversal**: Start from v1, requires walking entire chain
- **Backward traversal**: Start from tip, follow `prev` links (efficient)
- **Random access**: Use `GET /entities/:pi/versions/ver:N` selector

### Component Updates

Components are partially updatable:
- Provide only changed components in `AppendVersionRequest`
- Server merges with previous version's components
- IPLD links are automatically created from plain CID strings

### Parent-Child Relationships

The API supports bidirectional parent-child relationships with **one-way automatic updates**:

**Automatic Updates (Child → Parent):**
- When creating an entity with `parent_pi`, the parent is automatically updated
- Parent's `children_pi` array gets the new child appended (new version created)
- Implemented in `src/services/entity-ops.ts:60-91`

**Manual Updates Required (Parent → Children):**
- When creating an entity with `children_pi`, children are NOT automatically updated
- You must use `POST /relations` endpoint to establish bidirectional links
- This prevents CPU timeout issues with large child arrays

**Best Practice for Nested Structures:**

```typescript
// 1. Create children first (no parent specified)
const child1 = await createEntity({ components: {...} });
const child2 = await createEntity({ components: {...} });

// 2. Create parent (optionally with children_pi, but not linked yet)
const parent = await createEntity({ components: {...} });

// 3. Use /relations endpoint for bidirectional linking (supports bulk)
await POST('/relations', {
  parent_pi: parent.pi,
  expect_tip: parent.tip,
  add_children: [child1.pi, child2.pi]  // Arrays supported for bulk
});
// This updates parent AND all children in one call
```

**Bulk Operations:**
- `POST /relations` accepts arrays: `add_children`, `remove_children`
- Children are processed **in parallel batches of 10** using `processBatchedSettled()` for optimal performance and stability
- Batching prevents overwhelming Cloudflare Workers with too many concurrent requests
- Implementation: `src/utils/batch.ts` provides batched parallelization utilities
- Typical performance: ~500-700ms for 10 children, ~2-3s for 50 children, ~5-6s for 100 children
- **Maximum limit: 100 children per request** (enforced via validation in `relations.ts:34-44` and `versions.ts:59-69`)
- **Batch size: 10** (configurable via `BATCH_SIZE` constant in handlers)
- For batches over 100, split into multiple sequential API calls

**Implementation Files:**
- `src/services/entity-ops.ts` - Entity creation with `parent_pi` auto-update
- `src/handlers/relations.ts` - Bidirectional relationship updates (bulk)
- `src/handlers/versions.ts` - Version appending with `children_pi_add/remove` (bulk)

### Sharding Algorithm

```typescript
function shard2(ulid: string): [string, string] {
  return [ulid.slice(-4, -2), ulid.slice(-2)];
}
// "01K75HQQXNTDG7BBP7PS9AWYAN" → ["AW", "YA"]
```

Uses last 4 characters of ULID (from the 16-char random portion) for uniform distribution across 32^4 = 1,048,576 possible shard combinations. The first 10 chars of ULID are timestamp-based and change very slowly, so using them would cluster all data in the same few directories.

## Testing & Type Safety

- Type checking: `npm run type-check` (must pass before deployment)
- Test framework: Vitest
- TypeScript strict mode enabled
- Path alias: `@/*` maps to `./src/*`

## Environment Configuration

Set in `wrangler.jsonc`:
- `ENVIRONMENT` var (set to "production")
- `IPFS_API_URL` secret (Kubo node endpoint, e.g., http://ipfs-kubo:5001)
- `IPFS_SERVER_API_URL` secret (Backend API endpoint for event tracking, e.g., http://localhost:3000)
- Node.js compatibility enabled via `nodejs_compat` flag
- Worker CPU limit: 50ms

## References

See these files for complete specifications:
- `API_SPEC.md` - Full API endpoint documentation
- `BACKEND_API_WALKTHROUGH.md` - Backend event stream architecture and Kubo RPC usage
- `SCHEMA.md` - Detailed schema definitions and validation rules
- `QUICKSTART.md` - Quick start guide
- `DEPLOYMENT.md` - Deployment instructions
